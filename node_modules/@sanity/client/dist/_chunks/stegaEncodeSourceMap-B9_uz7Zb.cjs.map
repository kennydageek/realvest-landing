{"version":3,"file":"stegaEncodeSourceMap-B9_uz7Zb.cjs","sources":["../../src/stega/encodeIntoResult.ts","../../src/stega/filterDefault.ts","../../src/stega/stegaEncodeSourceMap.ts"],"sourcesContent":["import {parseJsonPath} from '../csm/jsonPath'\nimport {resolveMapping} from '../csm/resolveMapping'\nimport type {ContentSourceMap} from '../csm/types'\nimport {walkMap} from '../csm/walkMap'\nimport type {Encoder} from './types'\n\n/**\n * @internal\n */\nexport function encodeIntoResult<Result>(\n  result: Result,\n  csm: ContentSourceMap,\n  encoder: Encoder,\n): Result {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const {mapping, matchedPath} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = csm.documents[mapping.source.document!]\n    const sourcePath = csm.paths[mapping.source.path]\n\n    const matchPathSegments = parseJsonPath(matchedPath)\n    const sourcePathSegments = parseJsonPath(sourcePath)\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length))\n\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value,\n    })\n  }) as Result\n}\n","import type {FilterDefault} from './types'\n\nexport const filterDefault: FilterDefault = ({sourcePath, value}) => {\n  // Skips encoding on URL or Date strings, similar to the `skip: 'auto'` parameter in vercelStegaCombine()\n  if (isValidDate(value) || isValidURL(value)) {\n    return false\n  }\n\n  const endPath = sourcePath.at(-1)\n  // Never encode slugs\n  if (sourcePath.at(-2) === 'slug' && endPath === 'current') {\n    return false\n  }\n\n  // Skip underscored keys, needs better heuristics but it works for now\n  if (typeof endPath === 'string' && endPath.startsWith('_')) {\n    return false\n  }\n\n  /**\n   * Best effort infer Portable Text paths that should not be encoded.\n   * Nothing is for certain, and the below implementation may cause paths that aren't Portable Text and otherwise be safe to encode to be skipped.\n   * However, that's ok as userland can always opt-in with the `encodeSourceMapAtPath` option and mark known safe paths as such, which will override this heuristic.\n   */\n  // If the path ends in marks[number] it's likely a PortableTextSpan: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#LL154C16-L154C16\n  if (typeof endPath === 'number' && sourcePath.at(-2) === 'marks') {\n    return false\n  }\n  // Or if it's [number].markDefs[number].href it's likely a PortableTextLink: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L163\n  if (\n    endPath === 'href' &&\n    typeof sourcePath.at(-2) === 'number' &&\n    sourcePath.at(-3) === 'markDefs'\n  ) {\n    return false\n  }\n  // Otherwise we have to deal with special properties of PortableTextBlock, and we can't confidently know if it's actually a `_type: 'block'` array item or not.\n  // All we know is that if it is indeed a block, and we encode the strings on these keys it'll for sure break the PortableText rendering and thus we skip encoding.\n  // https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L48-L58\n  if (endPath === 'style' || endPath === 'listItem') {\n    return false\n  }\n\n  // Don't encode into anything that is suggested it'll render for SEO in meta tags\n  if (\n    sourcePath.some(\n      (path) => path === 'meta' || path === 'metadata' || path === 'openGraph' || path === 'seo',\n    )\n  ) {\n    return false\n  }\n\n  // Finally, we ignore a bunch of paths that are typically used for page building\n  if (typeof endPath === 'string' && denylist.has(endPath)) {\n    return false\n  }\n\n  return true\n}\n\nconst denylist = new Set([\n  'color',\n  'colour',\n  'currency',\n  'email',\n  'format',\n  'gid',\n  'hex',\n  'href',\n  'hsl',\n  'hsla',\n  'icon',\n  'id',\n  'index',\n  'key',\n  'language',\n  'layout',\n  'link',\n  'linkAction',\n  'locale',\n  'lqip',\n  'page',\n  'path',\n  'ref',\n  'rgb',\n  'rgba',\n  'route',\n  'secret',\n  'slug',\n  'status',\n  'tag',\n  'template',\n  'theme',\n  'type',\n  'unit',\n  'url',\n  'username',\n  'variant',\n  'website',\n])\n\nfunction isValidDate(dateString: string) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false\n}\n\nfunction isValidURL(url: string) {\n  try {\n    new URL(url, url.startsWith('/') ? 'https://acme.com' : undefined)\n  } catch {\n    return false\n  }\n  return true\n}\n","import {vercelStegaCombine} from '@vercel/stega'\n\nimport {createEditUrl} from '../csm/createEditUrl'\nimport {jsonPathToStudioPath} from '../csm/jsonPath'\nimport {resolveStudioBaseRoute} from '../csm/resolveEditInfo'\nimport {reKeySegment, toString as studioPathToString} from '../csm/studioPath'\nimport {encodeIntoResult} from './encodeIntoResult'\nimport {filterDefault} from './filterDefault'\nimport {ContentSourceMap, ContentSourceMapParsedPath, InitializedStegaConfig} from './types'\n\nconst TRUNCATE_LENGTH = 20\n\n/**\n * Uses `@vercel/stega` to embed edit info JSON into strings in your query result.\n * The JSON payloads are added using invisible characters so they don't show up visually.\n * The edit info is generated from the Content Source Map (CSM) that is returned from Sanity for the query.\n * @public\n */\nexport function stegaEncodeSourceMap<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  config: InitializedStegaConfig,\n): Result {\n  const {filter, logger, enabled} = config\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\"\n    logger?.error?.(`[@sanity/client]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  if (!resultSourceMap) {\n    logger?.error?.('[@sanity/client]: Missing Content Source Map from response body', {\n      result,\n      resultSourceMap,\n      config,\n    })\n    return result\n  }\n\n  if (!config.studioUrl) {\n    const msg = 'config.studioUrl must be defined'\n    logger?.error?.(`[@sanity/client]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  const report: Record<'encoded' | 'skipped', {path: string; length: number; value: string}[]> = {\n    encoded: [],\n    skipped: [],\n  }\n\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({sourcePath, sourceDocument, resultPath, value}) => {\n      // Allow userland to control when to opt-out of encoding\n      if (\n        (typeof filter === 'function'\n          ? filter({sourcePath, resultPath, filterDefault, sourceDocument, value})\n          : filterDefault({sourcePath, resultPath, filterDefault, sourceDocument, value})) === false\n      ) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: `${value.slice(0, TRUNCATE_LENGTH)}${\n              value.length > TRUNCATE_LENGTH ? '...' : ''\n            }`,\n            length: value.length,\n          })\n        }\n        return value\n      }\n\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? '...' : ''}`,\n          length: value.length,\n        })\n      }\n\n      const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n        typeof config.studioUrl === 'function'\n          ? config.studioUrl(sourceDocument)\n          : config.studioUrl!,\n      )\n      if (!baseUrl) return value\n      const {_id: id, _type: type, _projectId: projectId, _dataset: dataset} = sourceDocument\n\n      return vercelStegaCombine(\n        value,\n        {\n          origin: 'sanity.io',\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...(!config.omitCrossDatasetReferenceData && {dataset, projectId}),\n          }),\n        },\n        // We use custom logic to determine if we should skip encoding\n        false,\n      )\n    },\n  )\n\n  if (logger) {\n    const isSkipping = report.skipped.length\n    const isEncoding = report.encoded.length\n    if (isSkipping || isEncoding) {\n      ;(logger?.groupCollapsed || logger.log)?.('[@sanity/client]: Encoding source map into result')\n      logger.log?.(\n        `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`,\n      )\n    }\n    if (report.encoded.length > 0) {\n      logger?.log?.(`[@sanity/client]: Table of encoded paths`)\n      ;(logger?.table || logger.log)?.(report.encoded)\n    }\n    if (report.skipped.length > 0) {\n      const skipped = new Set<string>()\n      for (const {path} of report.skipped) {\n        skipped.add(path.replace(reKeySegment, '0').replace(/\\[\\d+\\]/g, '[]'))\n      }\n      logger?.log?.(`[@sanity/client]: List of skipped paths`, [...skipped.values()])\n    }\n\n    if (isSkipping || isEncoding) {\n      logger?.groupEnd?.()\n    }\n  }\n\n  return resultWithStega\n}\n\nfunction prettyPathForLogging(path: ContentSourceMapParsedPath): string {\n  return studioPathToString(jsonPathToStudioPath(path))\n}\n"],"names":["walkMap","resolveMapping","parseJsonPath","resolveStudioBaseRoute","vercelStegaCombine","createEditUrl","reKeySegment","studioPathToString","jsonPathToStudioPath"],"mappings":"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"}